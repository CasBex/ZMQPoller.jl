var documenterSearchIndex = {"docs":
[{"location":"api/#Reference","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/#ZMQPoller.PollItems","page":"API","title":"ZMQPoller.PollItems","text":"PollItems(socks::Vector{Socket}, events::Vector{<:Integer})\n\nCreate a PollItems object to poll multiple sockets simultaneously. socks is the vector of sockets to poll. events represents ZMQ events to poll for. Valid values for events entries are ZMQ.POLLIN, ZMQ.POLLOUT and ZMQ.POLLIN | ZMQ.POLLOUT.\n\nThis object creates a poller and starts the necessary background tasks. To actually poll the sockets, use poll. The poll result is written to the revents field of the PollItems struct.\n\nWhen the poller is no longer needed, it is recommended to call close(items::PollItems).\n\nwarning: Warning\nThis spawns tasks using @async, meaning that the task that instantiates the PollItems object will become sticky. For more info refer to the @async documentation.\n\n\n\n\n\n","category":"type"},{"location":"api/#ZMQPoller.poll","page":"API","title":"ZMQPoller.poll","text":"poll(p::PollItems, timeout = -1)\n\nPoll the PollItems for events. If no timeout is provided, this blocks until an event occurs. Otherwise it sleeps for timeout miliseconds and returns the amount of sockets for which an event occured.\n\nNote on event indicators and the poller\n\nThe poller returns the amount of sockets for which events occured. This is not the same as the amount of messages which can be received/sent. The following scenarios are valid:\n\nSocket 1 receives 1 message, the poller returns 1\nSocket 1 receives 10 messages, the poller returns 1\nSocket 1 receives 10 messages and socket 2 receives 1 message, the poller returns 2\nSocket 1 receives 10 messages and socket 2 receives 10 messages, the poller returns 2\n\n\n\n\n\n","category":"function"},{"location":"deprecate/#Remove-ZMQPoller-From-a-Program","page":"Remove ZMQPoller From a Program","title":"Remove ZMQPoller From a Program","text":"","category":"section"},{"location":"deprecate/","page":"Remove ZMQPoller From a Program","title":"Remove ZMQPoller From a Program","text":"ZMQPoller.jl allows to read multiple sockets simultaneously, possibly providing a timeout.  An alternative to polling sockets through the filewatcher mechanism, which will trigger as soon as a socket receives a message, is to periodically check them for messages. This is slower than using the filewatcher but is simple enough to implement.","category":"page"},{"location":"deprecate/","page":"Remove ZMQPoller From a Program","title":"Remove ZMQPoller From a Program","text":"Consider below snippet from the tutorial, which polls three sockets.","category":"page"},{"location":"deprecate/","page":"Remove ZMQPoller From a Program","title":"Remove ZMQPoller From a Program","text":"function main_poller()\n    ctx = Context()\n\n    receiver = Socket(ctx, PULL)\n    connect(receiver, ventilator_addr)\n\n    subscriber = Socket(ctx, SUB)\n    connect(subscriber, weather_addr)\n    subscribe(subscriber, \"\")\n\n    killer = Socket(ctx, SUB)\n    connect(killer, kill_addr)\n    subscribe(killer, \"\")\n\n    items = PollItems([receiver, subscriber, killer], [ZMQ.POLLIN, ZMQ.POLLIN, ZMQ.POLLIN])\n\n    while true\n        poll(items)\n        if items.revents[1] & ZMQ.POLLIN != 0\n            msg = recv(receiver, String)\n            sleep(rand())\n            println(\"Received task $msg\")\n        end\n        if items.revents[2] & ZMQ.POLLIN != 0\n            msg = recv(subscriber, String)\n            sleep(rand())\n            println(\"Received subscription $msg\")\n        end\n        if items.revents[3] & ZMQ.POLLIN != 0\n            println(\"Received kill signal\")\n            break\n        end\n    end\n    return\nend","category":"page"},{"location":"deprecate/","page":"Remove ZMQPoller From a Program","title":"Remove ZMQPoller From a Program","text":"Instead of using a poller, one could opt for the code below. This will cause more CPU cycles, and higher latency, but avoids the Heisenbugs in the poller implementation.","category":"page"},{"location":"deprecate/","page":"Remove ZMQPoller From a Program","title":"Remove ZMQPoller From a Program","text":"function main_poller()\n    ctx = Context()\n\n    receiver = Socket(ctx, PULL)\n    connect(receiver, ventilator_addr)\n\n    subscriber = Socket(ctx, SUB)\n    connect(subscriber, weather_addr)\n    subscribe(subscriber, \"\")\n\n    killer = Socket(ctx, SUB)\n    connect(killer, kill_addr)\n    subscribe(killer, \"\")\n\t\n\tdelay = 1.0e-2 # 10 ms\n\n    while true\n\t\t# while loops will read multiple messages \n\t\t# so they're preferable to an if statement\n        while receiver.events & ZMQ.POLLIN != 0\n            msg = recv(receiver, String)\n            sleep(rand())\n            println(\"Received task $msg\")\n        end\n        while subscriber.events & ZMQ.POLLIN != 0\n            msg = recv(subscriber, String)\n            sleep(rand())\n            println(\"Received subscription $msg\")\n        end\n        while killer.events & ZMQ.POLLIN != 0\n            println(\"Received kill signal\")\n            break\n        end\n\t\tsleep(delay)\n    end\n    return\nend","category":"page"},{"location":"#ZMQPoller.jl","page":"Home","title":"ZMQPoller.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements a ZMQ socket poller that integrates with the Julia task scheduler.","category":"page"},{"location":"","page":"Home","title":"Home","text":"error: Error\nThis package has been found to sometimes cause segmentation faults. Despite tests working in this repository it is strongly advised against to use this in your work!","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThis poller has not been accepted for merging into ZMQ.jl due to differing opinions on technical aspects. The author of this package stands by this implementation's correctness, supported by the test suite. For further context refer to the original discussion.Disclaimer: This package is intended to provide a practical, working solution, not to make a point or reopen past discussions. Please do not engage in the original PR thread unless you have new, substantial insights. If you encounter issues with this implementation specifically, feel free to open an issue here.","category":"page"},{"location":"tutorial/#Multiple-Sockets","page":"Tutorial","title":"Multiple Sockets","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Many ZMQ applications use multiple sockets. Unfortunately, integrating the ZMQ with the Julia task scheduler can be tricky and the optimal way to write a program with multiple sockets depends on your use case. In general there are two use cases to distinguish: ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"An application forwards messages between multiple sockets that do not expect replies (like in PUSH/PULL), or it listens on multiple sockets but does not forward messages between them. A typical example is a worker that may not only receives tasks/sends results via PULL and PUSH sockets, but also listens for a broadcast signal on a SUB socket. Another example is an application that monitors a heartbeat on socket 1 and sends data over socket 2.\nAn application forwards messages between multiple sockets which expect replies. A typical use case is a broker forwarding messages between clients and workers.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In case 1, it is advisable to spawn a task for each socket and communicate internally using Julia async tools. In case 2, a poller is your best option. The next tutorials illustrate this.","category":"page"},{"location":"tutorial/#Handling-multiple-receive-only-and/or-send-only-sockets","page":"Tutorial","title":"Handling multiple receive-only and/or send-only sockets","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial illustrates two approaches to program a basic message poller, inspired by the example in the ZMQ guide. Suppose an application wants to read from a weather forecast service which uses a ZMQ PUB socket and simultaneously acts as a worker for a task ventilator, which publishes its tasks over a ZMQ PUSH socket. To allow the program to exit cleanly, we additionally add a kill socket that shuts down the application. As such, the application has in total three sockets to read from: a SUB socket for the weather updates, a PULL socket for the tasks and a SUB socket for the killswitch. None of these sockets can send back messages.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The code below implements the task ventilator, weather server and kill service.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using ZMQ\nusing ZMQPoller\n\nconst kill_addr = \"tcp://localhost:5558\"\nconst ventilator_addr = \"tcp://localhost:5557\"\nconst weather_addr = \"tcp://localhost:5556\"\n\nfunction ventilator()\n    ctx = Context()\n    sender = Socket(ctx, PUSH)\n    bind(sender, ventilator_addr)\n    for i in 1:5\n        sleep(rand() * 3)\n        send(sender, string(i))\n    end\n    return\nend\n\nfunction weatherserver()\n    # allow the main to come online first\n    # to avoid dropped messages.\n    # this is not reliable but it suffices\n    # for this tutorial\n    sleep(1)\n    ctx = Context()\n    sender = Socket(ctx, PUB)\n    bind(sender, weather_addr)\n    for i in 1:5\n        sleep(rand() * 3)\n        send(sender, string(i))\n    end\n    return\nend\n\nfunction killmain()\n    ctx = Context()\n    sender = Socket(ctx, PUB)\n    bind(sender, kill_addr)\n    send(sender, \"\")\n    return\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Note\nWe could have just as easily created a single ZMQ context and passed it to all functions as an argument, but in this example the approaches with a shared or with individual contexts are equivalent.","category":"page"},{"location":"tutorial/#ZMQ-Poller","page":"Tutorial","title":"ZMQ Poller","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Arguably the easiest way to implement the application is by using a ZMQ poller. Simply connect each socket and create a PollItems object like below. The poller integrates with the Julia task system, and as such can be used in combination with regular Julia tasks.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function main_poller()\n    ctx = Context()\n\n    receiver = Socket(ctx, PULL)\n    connect(receiver, ventilator_addr)\n\n    subscriber = Socket(ctx, SUB)\n    connect(subscriber, weather_addr)\n    subscribe(subscriber, \"\")\n\n    killer = Socket(ctx, SUB)\n    connect(killer, kill_addr)\n    subscribe(killer, \"\")\n\n    items = PollItems([receiver, subscriber, killer], [ZMQ.POLLIN, ZMQ.POLLIN, ZMQ.POLLIN])\n\n    while true\n        poll(items)\n        if items.revents[1] & ZMQ.POLLIN != 0\n            msg = recv(receiver, String)\n            sleep(rand())\n            println(\"Received task $msg\")\n        end\n        if items.revents[2] & ZMQ.POLLIN != 0\n            msg = recv(subscriber, String)\n            sleep(rand())\n            println(\"Received subscription $msg\")\n        end\n        if items.revents[3] & ZMQ.POLLIN != 0\n            println(\"Received kill signal\")\n            break\n        end\n    end\n    return\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To run this example.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"import Base.Threads: @spawn\n\ntvent = @spawn ventilator()\ntweath = @spawn weatherserver()\ntmain = @spawn main_poller()\n\nwait(tvent)\nwait(tweath)\nkillmain()\nwait(tmain)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"While this program looks simple and clean, the poller has some drawbacks with respect to performance. The poller internally uses @async to schedule tasks that listen to each socket which makes the poll task a sticky task, meaning the tmain task cannot migrate across Julia threads. If the same thread is occupied by both the poller and another task, then the poller cannot receive messages while that other task is running. For this reason, it is preferable to use plain Julia tasks like below. Alternatively one can manually manage threads using Threadpools.jl or similar tools to avoid this problem.","category":"page"},{"location":"tutorial/#Use-Julia-Tasks","page":"Tutorial","title":"Use Julia Tasks","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Instead of polling multiple sockets in a single task, it's possible to start one task per socket that you want to listen on like below (in fact, this closely resembles how the poller works internally). In this example we use a channel to communicate the data to a single worker loop.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function main_tasks()\n    ctx = Context()\n    c = Channel{Tuple{String, String}}()\n\n    t1 = @spawn begin\n        receiver = Socket(ctx, PULL)\n        connect(receiver, ventilator_addr)\n        while true\n            msg = recv(receiver, String)\n            put!(c, (\"ventilator\", msg))\n        end\n    end\n\n    t2 = @spawn begin\n        subscriber = Socket(ctx, SUB)\n        connect(subscriber, weather_addr)\n        subscribe(subscriber, \"\")\n        while true\n            msg = recv(subscriber, String)\n            put!(c, (\"weather\", msg))\n        end\n    end\n\n    t3 = @spawn begin\n        killer = Socket(ctx, SUB)\n        connect(killer, kill_addr)\n        subscribe(killer, \"\")\n        while true\n            msg = recv(killer, String)\n            put!(c, (\"kill\", msg))\n        end\n    end\n\n    workerloop = @spawn while true\n        source, msg = take!(c)\n        if source == \"ventilator\"\n            sleep(rand())\n            println(\"Received task $msg\")\n        elseif source == \"weather\"\n            sleep(rand())\n            println(\"Received subscription $msg\")\n        elseif source == \"kill\"\n            sleep(rand())\n            println(\"Received kill signal\")\n            break\n        end\n    end\n\t\n    wait(workerloop)\n\n    for t in (t1, t2, t3)\n        schedule(t, InterruptException, error = true)\n    end\n\n    return\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To run the program.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"import Base.Threads: @spawn\n\ntvent = @spawn ventilator()\ntweath = @spawn weatherserver()\ntmain = @spawn main_tasks()\n\nwait(tvent)\nwait(tweath)\nkillmain()\nwait(tmain)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Contrary to the approach with poller, all tasks are able to migrate across Julia threads, so there is no associated performance penalty. This approach is a bit more verbose than the ZMQ poller, but from a technical perspective it is the superior option.","category":"page"},{"location":"tutorial/#Receiving-and-sending-on-multiple-sockets","page":"Tutorial","title":"Receiving and sending on multiple sockets","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Above example was relatively simple because the application does not need to respond when it receives a message. In this example we'll implement a broker that receives a message, forwards it to a worker and then replies to the client it received the message from. Clients use a simple REQ socket to send a number to the broker. The broker uses a ROUTER socket to receive requests from clients and uses a DEALER socket to talk to the worker. Workers use a REP socket to receive tasks and reply back. Additionally, we'll use a kill signal to stop the broker and workers.","category":"page"},{"location":"tutorial/#Clients","page":"Tutorial","title":"Clients","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"const broker_frontend = \"tcp://localhost:5560\"\nconst broker_backend = \"tcp://localhost:5561\"\n\nfunction client(i)\n    ctx = Context()\n    sock = Socket(ctx, REQ)\n    connect(sock, broker_frontend)\n    for j in 1:i\n        println(\"Client $i sends $j\")\n        send(sock, \"$j\")\n        k = recv(sock, String)\n        println(\"Client $i got $k\")\n    end\n    close(sock)\n    return\nend","category":"page"},{"location":"tutorial/#Worker","page":"Tutorial","title":"Worker","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The worker implementation could be done with a poller or with regular Julia tasks. Both are valid approaches, and what to do depends on personal preference. In a scenario where each worker is pinned to its own thread, the worker with poller would not be a bad implementation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function worker(i)\n    ctx = Context()\n    sock = Socket(ctx, REP)\n    connect(sock, broker_backend)\n    killsock = Socket(ctx, SUB)\n    connect(killsock, kill_addr)\n    subscribe(killsock, \"\")\n    poller = PollItems([sock, killsock], [ZMQ.POLLIN, ZMQ.POLLIN])\n    println(\"Worker online\")\n    while true\n        poll(poller)\n        poller.revents[2] & ZMQ.POLLIN != 0 && break\n        if poller.revents[1] & ZMQ.POLLIN != 0\n            j = parse(Int, recv(sock, String))\n            println(\"Worker $i got $j\")\n            k = j^2\n            println(\"Worker $i replies $k\")\n            send(sock, \"$k\")\n        end\n    end\n    close(poller)\n    return\nend\n\nfunction worker_with_tasks(i)\n    ctx = Context()\n    t1 = @spawn begin\n        sock = Socket(ctx, REP)\n        connect(sock, broker_backend)\n        while true\n            j = parse(Int, recv(sock, String))\n            println(\"Worker $i got $j\")\n            k = j^2\n            println(\"Worker $i replies $k\")\n            send(sock, \"$k\")\n        end\n    end\n    t2 = @spawn begin\n        killsock = Socket(ctx, SUB)\n        connect(killsock, kill_addr)\n        subscribe(killsock, \"\")\n        recv(killsock)\n    end\n    wait(t2)\n    schedule(t1, InterruptException(), error = true)\n    return\nend","category":"page"},{"location":"tutorial/#Poller-based-broker","page":"Tutorial","title":"Poller-based broker","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The broker is implemented with a poller. In this case there is a fundamental need to receive messages from both sockets and forward them to the other, which cannot be easily achieved with Julia tasks.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function broker()\n    ctx = Context()\n    frontend = Socket(ctx, ROUTER)\n    bind(frontend, broker_frontend)\n\n    backend = Socket(ctx, DEALER)\n    bind(backend, broker_backend)\n\n    killer = Socket(ctx, SUB)\n    connect(killer, kill_addr)\n    subscribe(killer, \"\")\n\n    poller = PollItems(\n        [frontend, backend, killer],\n        [ZMQ.POLLIN, ZMQ.POLLIN, ZMQ.POLLIN]\n    )\n    println(\"Broker online\")\n    while true\n        poll(poller)\n        poller.revents[3] & ZMQ.POLLIN != 0 && break\n        # backend -> frontend\n        if poller.revents[2] & ZMQ.POLLIN != 0\n            msg = recv_multipart(backend)\n            for i in eachindex(msg)\n                send(frontend, msg[i], more = i != lastindex(msg))\n            end\n        end\n        # frontend -> backend\n        if poller.revents[1] & ZMQ.POLLIN != 0\n            msg = recv_multipart(frontend)\n            for i in eachindex(msg)\n                more = i != lastindex(msg)\n                send(backend, msg[i]; more)\n            end\n        end\n    end\n\n    close(poller)\n    println(\"Finishing\")\n    return\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To run the example.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"broker_task = @spawn broker()\nworker_tasks = vcat(map(i -> @spawn(worker(i)), 1:2), map(i -> @spawn(worker_with_tasks(i)), 3:4))\nclient_tasks = map(i -> @spawn(client(i)), 1:3)\n\nforeach(wait, client_tasks)\nkillmain()\nforeach(wait, worker_tasks)\nwait(broker_task)","category":"page"},{"location":"tutorial/#Why-no-task-based-broker?","page":"Tutorial","title":"Why no task-based broker?","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A naive implementation of the broker above could be implemented like below. This is incorrect and should never be done. ZMQ sockets are not thread-safe, and doing this may result in a deadlock or a crash of the application. Even if the @spawn calls were replaced by @async the order of send/recv calls is not known and deadlocks could occur.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function broken_broker()\n    ctx = Context()\n\n    frontend = Socket(ctx, ROUTER)\n    bind(frontend, broker_frontend)\n\n    backend = Socket(ctx, DEALER)\n    bind(backend, broker_backend)\n\n    killer = Socket(ctx, SUB)\n    connect(killer, kill_addr)\n    subscribe(killer, \"\")\n\n    t1 = @spawn begin\n        while true\n            msg = recv_multipart(frontend)\n            for i in eachindex(msg)\n                more = i != lastindex(msg)\n                send(backend, msg[i]; more)\n            end\n        end\n    end\n    t2 = @spawn begin\n        while true\n            msg = recv_multipart(backend)\n            for i in eachindex(msg)\n                more = i != lastindex(msg)\n                send(frontend, msg[i]; more)\n            end\n        end\n    end\n    t3 = @spawn begin\n        recv(killer)\n    end\n    wait(t3)\n    schedule(t1, InterruptException(), error = true)\n    schedule(t2, InterruptException(), error = true)\n    return\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The application will not have the expected behaviour. Try to run it with below snippet.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"broker_task = @spawn broken_broker()\nworker_tasks = vcat(map(i -> @spawn(worker(i)), 1:2), map(i -> @spawn(worker_with_tasks(i)), 3:4))\nclient_tasks = map(i -> @spawn(client(i)), 1:3)\n\nforeach(wait, client_tasks)\nkillmain()\nforeach(wait, worker_tasks)\nwait(broker_task)","category":"page"}]
}
