<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · ZMQPoller.jl</title><meta name="title" content="Tutorial · ZMQPoller.jl"/><meta property="og:title" content="Tutorial · ZMQPoller.jl"/><meta property="twitter:title" content="Tutorial · ZMQPoller.jl"/><meta name="description" content="Documentation for ZMQPoller.jl."/><meta property="og:description" content="Documentation for ZMQPoller.jl."/><meta property="twitter:description" content="Documentation for ZMQPoller.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ZMQPoller.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Handling-multiple-receive-only-and/or-send-only-sockets"><span>Handling multiple receive-only and/or send-only sockets</span></a></li><li><a class="tocitem" href="#Receiving-and-sending-on-multiple-sockets"><span>Receiving and sending on multiple sockets</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CasBex/ZMQPoller.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CasBex/ZMQPoller.jl/blob/main/docs/src/tutorial.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Multiple-Sockets"><a class="docs-heading-anchor" href="#Multiple-Sockets">Multiple Sockets</a><a id="Multiple-Sockets-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Sockets" title="Permalink"></a></h1><p>Many ZMQ applications use multiple sockets. Unfortunately, integrating the ZMQ with the Julia task scheduler can be tricky and the optimal way to write a program with multiple sockets depends on your use case. In general there are two use cases to distinguish: </p><ol><li>An application forwards messages between multiple sockets that do not expect replies (like in PUSH/PULL), or it listens on multiple sockets but does not forward messages between them. A typical example is a worker that may not only receives tasks/sends results via PULL and PUSH sockets, but also listens for a broadcast signal on a SUB socket. Another example is an application that monitors a heartbeat on socket 1 and sends data over socket 2.</li><li>An application forwards messages between multiple sockets which expect replies. A typical use case is a broker forwarding messages between clients and workers.</li></ol><p>In case 1, it is advisable to spawn a task for each socket and communicate internally using Julia async tools. In case 2, a poller is your best option. The next tutorials illustrate this.</p><h2 id="Handling-multiple-receive-only-and/or-send-only-sockets"><a class="docs-heading-anchor" href="#Handling-multiple-receive-only-and/or-send-only-sockets">Handling multiple receive-only and/or send-only sockets</a><a id="Handling-multiple-receive-only-and/or-send-only-sockets-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-multiple-receive-only-and/or-send-only-sockets" title="Permalink"></a></h2><p>This tutorial illustrates two approaches to program a basic message poller, inspired by the example in the <a href="https://zguide.zeromq.org/docs/chapter2/#Handling-Multiple-Sockets">ZMQ guide</a>. Suppose an application wants to read from a weather forecast service which uses a ZMQ PUB socket and simultaneously acts as a worker for a task ventilator, which publishes its tasks over a ZMQ PUSH socket. To allow the program to exit cleanly, we additionally add a kill socket that shuts down the application. As such, the application has in total three sockets to read from: a SUB socket for the weather updates, a PULL socket for the tasks and a SUB socket for the killswitch. None of these sockets can send back messages.</p><p>The code below implements the task ventilator, weather server and kill service.</p><pre><code class="language-julia hljs">using ZMQ
using ZMQPoller

const kill_addr = &quot;tcp://localhost:5558&quot;
const ventilator_addr = &quot;tcp://localhost:5557&quot;
const weather_addr = &quot;tcp://localhost:5556&quot;

function ventilator()
    ctx = Context()
    sender = Socket(ctx, PUSH)
    bind(sender, ventilator_addr)
    for i in 1:5
        sleep(rand() * 3)
        send(sender, string(i))
    end
    return
end

function weatherserver()
    # allow the main to come online first
    # to avoid dropped messages.
    # this is not reliable but it suffices
    # for this tutorial
    sleep(1)
    ctx = Context()
    sender = Socket(ctx, PUB)
    bind(sender, weather_addr)
    for i in 1:5
        sleep(rand() * 3)
        send(sender, string(i))
    end
    return
end

function killmain()
    ctx = Context()
    sender = Socket(ctx, PUB)
    bind(sender, kill_addr)
    send(sender, &quot;&quot;)
    return
end</code></pre><div class="admonition is-info" id="Note-b96758df5351e736"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b96758df5351e736" title="Permalink"></a></header><div class="admonition-body"><p>We could have just as easily created a single ZMQ context and passed it to all functions as an argument, but in this example the approaches with a shared or with individual contexts are equivalent.</p></div></div><h3 id="ZMQ-Poller"><a class="docs-heading-anchor" href="#ZMQ-Poller">ZMQ Poller</a><a id="ZMQ-Poller-1"></a><a class="docs-heading-anchor-permalink" href="#ZMQ-Poller" title="Permalink"></a></h3><p>Arguably the easiest way to implement the application is by using a ZMQ poller. Simply connect each socket and create a <code>PollItems</code> object like below. The poller integrates with the Julia task system, and as such can be used in combination with regular Julia tasks.</p><pre><code class="language-julia hljs">function main_poller()
    ctx = Context()

    receiver = Socket(ctx, PULL)
    connect(receiver, ventilator_addr)

    subscriber = Socket(ctx, SUB)
    connect(subscriber, weather_addr)
    subscribe(subscriber, &quot;&quot;)

    killer = Socket(ctx, SUB)
    connect(killer, kill_addr)
    subscribe(killer, &quot;&quot;)

    items = PollItems([receiver, subscriber, killer], [ZMQ.POLLIN, ZMQ.POLLIN, ZMQ.POLLIN])

    while true
        poll(items)
        if items.revents[1] &amp; ZMQ.POLLIN != 0
            msg = recv(receiver, String)
            sleep(rand())
            println(&quot;Received task $msg&quot;)
        end
        if items.revents[2] &amp; ZMQ.POLLIN != 0
            msg = recv(subscriber, String)
            sleep(rand())
            println(&quot;Received subscription $msg&quot;)
        end
        if items.revents[3] &amp; ZMQ.POLLIN != 0
            println(&quot;Received kill signal&quot;)
            break
        end
    end
    return
end</code></pre><p>To run this example.</p><pre><code class="language-julia hljs">import Base.Threads: @spawn

tvent = @spawn ventilator()
tweath = @spawn weatherserver()
tmain = @spawn main_poller()

wait(tvent)
wait(tweath)
killmain()
wait(tmain)</code></pre><p>While this program looks simple and clean, the poller has some drawbacks with respect to performance. The poller internally uses <code>@async</code> to schedule tasks that listen to each socket which makes the poll task a sticky task, meaning the <code>tmain</code> task cannot migrate across Julia threads. If the same thread is occupied by both the poller and another task, then the poller cannot receive messages while that other task is running. For this reason, it is preferable to use plain Julia tasks like below. Alternatively one can manually manage threads using <a href="https://github.com/tro3/ThreadPools.jl">Threadpools.jl</a> or similar tools to avoid this problem.</p><h3 id="Use-Julia-Tasks"><a class="docs-heading-anchor" href="#Use-Julia-Tasks">Use Julia Tasks</a><a id="Use-Julia-Tasks-1"></a><a class="docs-heading-anchor-permalink" href="#Use-Julia-Tasks" title="Permalink"></a></h3><p>Instead of polling multiple sockets in a single task, it&#39;s possible to start one task per socket that you want to listen on like below (in fact, this closely resembles how the poller works internally). In this example we use a <a href="https://docs.julialang.org/en/v1/base/parallel/#Channels">channel</a> to communicate the data to a single worker loop.</p><pre><code class="language-julia hljs">function main_tasks()
    ctx = Context()
    c = Channel{Tuple{String, String}}()

    t1 = @spawn begin
        receiver = Socket(ctx, PULL)
        connect(receiver, ventilator_addr)
        while true
            msg = recv(receiver, String)
            put!(c, (&quot;ventilator&quot;, msg))
        end
    end

    t2 = @spawn begin
        subscriber = Socket(ctx, SUB)
        connect(subscriber, weather_addr)
        subscribe(subscriber, &quot;&quot;)
        while true
            msg = recv(subscriber, String)
            put!(c, (&quot;weather&quot;, msg))
        end
    end

    t3 = @spawn begin
        killer = Socket(ctx, SUB)
        connect(killer, kill_addr)
        subscribe(killer, &quot;&quot;)
        while true
            msg = recv(killer, String)
            put!(c, (&quot;kill&quot;, msg))
        end
    end

    workerloop = @spawn while true
        source, msg = take!(c)
        if source == &quot;ventilator&quot;
            sleep(rand())
            println(&quot;Received task $msg&quot;)
        elseif source == &quot;weather&quot;
            sleep(rand())
            println(&quot;Received subscription $msg&quot;)
        elseif source == &quot;kill&quot;
            sleep(rand())
            println(&quot;Received kill signal&quot;)
            break
        end
    end
	
    wait(workerloop)

    for t in (t1, t2, t3)
        schedule(t, InterruptException, error = true)
    end

    return
end</code></pre><p>To run the program.</p><pre><code class="language-julia hljs">import Base.Threads: @spawn

tvent = @spawn ventilator()
tweath = @spawn weatherserver()
tmain = @spawn main_tasks()

wait(tvent)
wait(tweath)
killmain()
wait(tmain)</code></pre><p>Contrary to the approach with poller, all tasks are able to migrate across Julia threads, so there is no associated performance penalty. This approach is a bit more verbose than the ZMQ poller, but from a technical perspective it is the superior option.</p><h2 id="Receiving-and-sending-on-multiple-sockets"><a class="docs-heading-anchor" href="#Receiving-and-sending-on-multiple-sockets">Receiving and sending on multiple sockets</a><a id="Receiving-and-sending-on-multiple-sockets-1"></a><a class="docs-heading-anchor-permalink" href="#Receiving-and-sending-on-multiple-sockets" title="Permalink"></a></h2><p>Above example was relatively simple because the application does not need to respond when it receives a message. In this example we&#39;ll implement a broker that receives a message, forwards it to a worker and then replies to the client it received the message from. Clients use a simple REQ socket to send a number to the broker. The broker uses a ROUTER socket to receive requests from clients and uses a DEALER socket to talk to the worker. Workers use a REP socket to receive tasks and reply back. Additionally, we&#39;ll use a kill signal to stop the broker and workers.</p><h3 id="Clients"><a class="docs-heading-anchor" href="#Clients">Clients</a><a id="Clients-1"></a><a class="docs-heading-anchor-permalink" href="#Clients" title="Permalink"></a></h3><pre><code class="language-julia hljs">const broker_frontend = &quot;tcp://localhost:5560&quot;
const broker_backend = &quot;tcp://localhost:5561&quot;

function client(i)
    ctx = Context()
    sock = Socket(ctx, REQ)
    connect(sock, broker_frontend)
    for j in 1:i
        println(&quot;Client $i sends $j&quot;)
        send(sock, &quot;$j&quot;)
        k = recv(sock, String)
        println(&quot;Client $i got $k&quot;)
    end
    close(sock)
    return
end</code></pre><h3 id="Worker"><a class="docs-heading-anchor" href="#Worker">Worker</a><a id="Worker-1"></a><a class="docs-heading-anchor-permalink" href="#Worker" title="Permalink"></a></h3><p>The worker implementation could be done with a poller or with regular Julia tasks. Both are valid approaches, and what to do depends on personal preference. In a scenario where each worker is pinned to its own thread, the worker with poller would not be a bad implementation.</p><pre><code class="language-julia hljs">function worker(i)
    ctx = Context()
    sock = Socket(ctx, REP)
    connect(sock, broker_backend)
    killsock = Socket(ctx, SUB)
    connect(killsock, kill_addr)
    subscribe(killsock, &quot;&quot;)
    poller = PollItems([sock, killsock], [ZMQ.POLLIN, ZMQ.POLLIN])
    println(&quot;Worker online&quot;)
    while true
        poll(poller)
        poller.revents[2] &amp; ZMQ.POLLIN != 0 &amp;&amp; break
        if poller.revents[1] &amp; ZMQ.POLLIN != 0
            j = parse(Int, recv(sock, String))
            println(&quot;Worker $i got $j&quot;)
            k = j^2
            println(&quot;Worker $i replies $k&quot;)
            send(sock, &quot;$k&quot;)
        end
    end
    close(poller)
    return
end

function worker_with_tasks(i)
    ctx = Context()
    t1 = @spawn begin
        sock = Socket(ctx, REP)
        connect(sock, broker_backend)
        while true
            j = parse(Int, recv(sock, String))
            println(&quot;Worker $i got $j&quot;)
            k = j^2
            println(&quot;Worker $i replies $k&quot;)
            send(sock, &quot;$k&quot;)
        end
    end
    t2 = @spawn begin
        killsock = Socket(ctx, SUB)
        connect(killsock, kill_addr)
        subscribe(killsock, &quot;&quot;)
        recv(killsock)
    end
    wait(t2)
    schedule(t1, InterruptException(), error = true)
    return
end</code></pre><h3 id="Poller-based-broker"><a class="docs-heading-anchor" href="#Poller-based-broker">Poller-based broker</a><a id="Poller-based-broker-1"></a><a class="docs-heading-anchor-permalink" href="#Poller-based-broker" title="Permalink"></a></h3><p>The broker is implemented with a poller. In this case there is a fundamental need to receive messages from both sockets and forward them to the other, which cannot be easily achieved with Julia tasks.</p><pre><code class="language-julia hljs">function broker()
    ctx = Context()
    frontend = Socket(ctx, ROUTER)
    bind(frontend, broker_frontend)

    backend = Socket(ctx, DEALER)
    bind(backend, broker_backend)

    killer = Socket(ctx, SUB)
    connect(killer, kill_addr)
    subscribe(killer, &quot;&quot;)

    poller = PollItems(
        [frontend, backend, killer],
        [ZMQ.POLLIN, ZMQ.POLLIN, ZMQ.POLLIN]
    )
    println(&quot;Broker online&quot;)
    while true
        poll(poller)
        poller.revents[3] &amp; ZMQ.POLLIN != 0 &amp;&amp; break
        # backend -&gt; frontend
        if poller.revents[2] &amp; ZMQ.POLLIN != 0
            msg = recv_multipart(backend)
            for i in eachindex(msg)
                send(frontend, msg[i], more = i != lastindex(msg))
            end
        end
        # frontend -&gt; backend
        if poller.revents[1] &amp; ZMQ.POLLIN != 0
            msg = recv_multipart(frontend)
            for i in eachindex(msg)
                more = i != lastindex(msg)
                send(backend, msg[i]; more)
            end
        end
    end

    close(poller)
    println(&quot;Finishing&quot;)
    return
end</code></pre><p>To run the example.</p><pre><code class="language-julia hljs">broker_task = @spawn broker()
worker_tasks = vcat(map(i -&gt; @spawn(worker(i)), 1:2), map(i -&gt; @spawn(worker_with_tasks(i)), 3:4))
client_tasks = map(i -&gt; @spawn(client(i)), 1:3)

foreach(wait, client_tasks)
killmain()
foreach(wait, worker_tasks)
wait(broker_task)</code></pre><h3 id="Why-no-task-based-broker?"><a class="docs-heading-anchor" href="#Why-no-task-based-broker?">Why no task-based broker?</a><a id="Why-no-task-based-broker?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-no-task-based-broker?" title="Permalink"></a></h3><p>A naive implementation of the broker above could be implemented like below. This is <strong>incorrect</strong> and should <strong>never</strong> be done. ZMQ sockets are not thread-safe, and doing this may result in a deadlock or a crash of the application. Even if the <code>@spawn</code> calls were replaced by <code>@async</code> the order of send/recv calls is not known and deadlocks could occur.</p><pre><code class="language-julia hljs">function broken_broker()
    ctx = Context()

    frontend = Socket(ctx, ROUTER)
    bind(frontend, broker_frontend)

    backend = Socket(ctx, DEALER)
    bind(backend, broker_backend)

    killer = Socket(ctx, SUB)
    connect(killer, kill_addr)
    subscribe(killer, &quot;&quot;)

    t1 = @spawn begin
        while true
            msg = recv_multipart(frontend)
            for i in eachindex(msg)
                more = i != lastindex(msg)
                send(backend, msg[i]; more)
            end
        end
    end
    t2 = @spawn begin
        while true
            msg = recv_multipart(backend)
            for i in eachindex(msg)
                more = i != lastindex(msg)
                send(frontend, msg[i]; more)
            end
        end
    end
    t3 = @spawn begin
        recv(killer)
    end
    wait(t3)
    schedule(t1, InterruptException(), error = true)
    schedule(t2, InterruptException(), error = true)
    return
end</code></pre><p>The application will not have the expected behaviour. Try to run it with below snippet.</p><pre><code class="language-julia hljs">broker_task = @spawn broken_broker()
worker_tasks = vcat(map(i -&gt; @spawn(worker(i)), 1:2), map(i -&gt; @spawn(worker_with_tasks(i)), 3:4))
client_tasks = map(i -&gt; @spawn(client(i)), 1:3)

foreach(wait, client_tasks)
killmain()
foreach(wait, worker_tasks)
wait(broker_task)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Friday 27 June 2025 09:51">Friday 27 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
